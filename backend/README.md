# Backend API Server (Next.js) – CivicTrack

This is a Next.js API-only backend server running on port 5000 for **CivicTrack** (transparent urban grievance redressal).

## Setup

1. Install dependencies:
```bash
npm install
```

2. Generate Prisma client:
```bash
npx prisma generate
```

3. Run migrations (if needed):
```bash
npx prisma migrate deploy
```

4. Start development server:
```bash
npm run dev
```

The server will start on http://localhost:5000

## API Routes

- `GET /api/health` - Health check
- `GET /api/test-db` - Test database connection
- `POST /api/auth/signup` - User signup
- `POST /api/auth/login` - User login
- `GET /api/issues` - List issues (query: category, status, limit, offset)
- `POST /api/issues` - Create issue (title, description, category, latitude, longitude, isAnonymous, reportedById)
- `GET /api/issues/:id` - Get issue by id or publicId (e.g. CT-00001)
- `PATCH /api/issues/:id` - Update issue (status, assignedToId, resolutionNotes, proofUrls, etc.)
- `DELETE /api/issues/:id` - Delete issue (admin only)

## CivicTrack: Role enum

User `role` is one of: **citizen**, **officer**, **admin**. If you have an existing database with the old Role enum (`user`, `admin`), run a migration to add new values and map existing data (e.g. set `user` → `citizen`) before or after applying schema changes; see Prisma docs for enum migrations.

## Authentication vs Authorization

- **Authentication** answers: _"Who are you?"_
  - Implemented by `POST /api/auth/signup` and `POST /api/auth/login`.
  - On login, the backend verifies the email/password with Prisma and issues a **JWT** that includes the user id, email, and `role` (either `"user"` or `"admin"`).
  - The JWT is signed with `JWT_SECRET` loaded from environment variables; no secrets are hardcoded in the codebase.
- **Authorization** answers: _"What are you allowed to do?"_
  - Implemented by role-based checks (`role` field on the `User` model and `role` claim in the JWT).
  - Middleware and API routes use the `role` to decide if access should be granted or denied.

## Authorization Middleware (RBAC) Flow

> Note: The global authorization middleware is implemented in the frontend Next.js app and protects the `/api/users` and `/api/admin` routes. It uses the same `JWT_SECRET` so it can verify the JWTs generated by this backend.

- **1. Incoming request**
  - Client calls one of:
    - `GET /api/users`
    - `GET /api/admin`
  - Request must include `Authorization: Bearer <JWT>` header.
- **2. Middleware checks**
  - If the `Authorization` header is **missing**:
    - Returns a JSON error with **HTTP 401** (unauthorized).
  - If the token is **invalid or expired**:
    - Returns a JSON error with **HTTP 403** (forbidden).
  - If the path starts with `/api/admin` and the user `role` in the token is **not** `"admin"`:
    - Returns a JSON error with **HTTP 403** (forbidden).
  - On success:
    - Middleware attaches decoded user information to the request headers:
      - `x-user-email`
      - `x-user-role`
    - Request is forwarded to the target API route.
- **3. API route behavior**
  - `/api/users`:
    - Requires a **valid JWT** (any role: `"user"` or `"admin"`).
  - `/api/admin`:
    - Requires a **valid JWT** with `role === "admin"`.

All error responses are JSON only (no redirects), and use the shared `responseHandler.ts` and `errorCodes.ts` utilities for a consistent response shape.

## Role-Based Access Control (RBAC)

The application implements a comprehensive RBAC system with permission-based access control. See [RBAC.md](./RBAC.md) for complete documentation.

### Roles & Permissions

| Role | Permissions | Description |
|------|-------------|-------------|
| **citizen** | `create`, `read` | Can create issues (report) and read/view issues |
| **officer** | `read`, `update` | Can read issues and update progress/status |
| **admin** | `create`, `read`, `update`, `delete` | Full access to all operations |

### Enforcement

- **Backend**: All API routes enforce permissions via centralized middleware
- **Frontend**: UI elements conditionally render based on user permissions
- **Logging**: All permission checks are logged for auditing

### Allowed vs Denied Examples

- **Allowed**
  - `POST /api/issues` with a valid JWT for a `"citizen"` (has `create` permission): ✅ Allowed
  - `PATCH /api/issues/:id` with a valid JWT for an `"officer"` (has `update` permission): ✅ Allowed
  - `GET /api/users/officers` with a valid JWT for an `"admin"` (has `read` permission): ✅ Allowed
  - `DELETE /api/issues/:id` with a valid JWT for an `"admin"` (has `delete` permission): ✅ Allowed

- **Denied**
  - `PATCH /api/issues/:id` with a valid JWT for a `"citizen"` (no `update` permission): ❌ Forbidden (HTTP 403)
  - `DELETE /api/issues/:id` with a valid JWT for an `"officer"` (no `delete` permission): ❌ Forbidden (HTTP 403)
  - `GET /api/users/officers` with a valid JWT for a `"citizen"` (no `read` permission for this resource): ❌ Forbidden (HTTP 403)

For detailed RBAC documentation, see [RBAC.md](./RBAC.md).

### Enforcement Flow

1. **Incoming request** → API route receives request with `Authorization: Bearer <JWT>`
2. **Verify JWT** → Extract and verify token; reject with 401 if invalid/expired
3. **Extract role** → Role comes from verified JWT payload only; never from body or frontend
4. **Check permission** → Use centralized `ROLE_PERMISSIONS` mapping; deny by default
5. **If allowed** → Proceed; log `[RBAC] role=X action=Y resource=Z result=ALLOWED`
6. **If denied** → Return 403; log `[RBAC] role=X action=Y resource=Z result=DENIED`

### Example Log Output

```
[RBAC] role=admin action=delete resource=/api/issues/123 result=ALLOWED
[RBAC] role=officer action=delete resource=/api/issues/456 result=DENIED
```

### Scalability, Auditing & Future Extension

- **Scalability**: Single `ROLE_PERMISSIONS` config; add roles/permissions by extending the mapping
- **Auditing**: All checks logged in consistent format; easy to pipe to log aggregators
- **Extension**: Add new roles (e.g. `moderator`) or permissions (e.g. `approve`) by updating `backend/src/lib/rbac/permissions.ts`

## Least-Privilege Principle

This project follows the **least-privilege principle**:

- New users are created with the lowest privilege by default:
  - `role = "user"`.
- Admin-only routes (`/api/admin`) are strictly guarded:
  - Only tokens with `role === "admin"` are allowed through middleware.
- Shared middleware centralizes authorization logic:
  - Reduces duplication and the chance of accidentally exposing sensitive routes.
- The `role` is part of the JWT payload:
  - API routes can make additional fine-grained checks when necessary without performing extra database lookups.

By default, users can only access what they need (`/api/users` with valid JWT), while sensitive admin operations are limited to a small, trusted set of identities.

## Redis Caching (Optional)

A production-ready Redis caching layer is integrated to improve API performance for frequently read data. **Redis is completely optional** - the application works perfectly fine without it.

### Why Redis was added

- **Reduce database load**: List and single-issue GETs are read-heavy; caching avoids repeated Prisma/PostgreSQL round-trips.
- **Lower latency**: Cached responses are served from memory (Redis), so cold vs cached request latency is measurably lower.
- **Same API contract**: Response shapes and status codes are unchanged; caching is transparent to clients.

### Cache-aside strategy (lazy loading)

- **Flow**: On a GET request we first check Redis. On **cache hit** we return the stored JSON immediately. On **cache miss** we load from the database, store the serialized response in Redis with a TTL, then return it.
- **Single Redis instance**: The app uses one shared Redis client (see `src/lib/redis.ts`); connection is created from `REDIS_URL` and reused.
- **Error safety**: If Redis is unavailable or any cache operation fails, the API does not crash: we log a warning once and fall back to the database. Responses remain correct. The app runs normally without Redis.

### Running without Redis

To run the application without Redis, simply **remove or comment out** the `REDIS_URL` line in your `.env` file:

```env
# REDIS_URL=redis://localhost:6379  # Commented out - app runs without cache
```

The application will automatically detect that Redis is not configured and run without caching. All API endpoints will work normally, they'll just query the database directly instead of using cache.

### TTL policy and reasoning

- **List endpoint** (`GET /api/issues`): Default TTL **60 seconds** (`CACHE_TTL_SECONDS`). List data can tolerate short staleness; 60s keeps DB load down while keeping lists reasonably fresh.
- **Single-issue** (`GET /api/issues/:id`): Default TTL **30 seconds** (`CACHE_TTL_ONE_SECONDS`). Shorter so status/assignment updates appear sooner when an issue is updated.
- TTLs are configurable via environment variables so production can tune for traffic and freshness.

### Cache invalidation

- **On mutations we invalidate related cache** so stale data is not served:
  - **POST /api/issues** (create): Invalidates all issue list cache keys (`issues:list:*`).
  - **PATCH /api/issues/:id** (update): Invalidates the list cache and the single-issue cache for that id (both numeric and `publicId`).
  - **DELETE /api/issues/:id**: Invalidates list cache and single-issue cache.
- Invalidation is explicit and intentional: only these mutation paths clear cache; no background TTL-only reliance for consistency.

### Observability

- Console logs indicate **CACHE HIT**, **CACHE MISS**, and **CACHE INVALIDATE** (with key or pattern and count). Use these for performance analysis and debugging.
- Redis connection and command errors are logged internally; they do not surface as 5xx to the client.

### Performance impact

- **Cold request** (cache miss): Same as before—one DB query; response is then stored in Redis.
- **Cached request** (cache hit): No DB query; response is read from Redis and returned. Latency is typically much lower (e.g. single-digit ms vs tens of ms for DB).
- Throughput improves under repeated reads for the same query params or issue id.

### Stale data risks and mitigation

- **Risk**: A client might see list or single-issue data that is slightly out of date (up to one TTL window) if they do not trigger a mutation.
- **Mitigation**: (1) Mutations (POST, PATCH) invalidate the relevant keys so the next GET sees fresh data. (2) TTL limits how long any stale entry can live. (3) If Redis fails, every request falls back to the database, so correctness is preserved.

## Environment Variables

Create a `.env` file with:
```
DATABASE_URL=postgresql://postgres:password@localhost:5432/mydb
PORT=5000
JWT_SECRET=your-secret-key
REDIS_URL=redis://localhost:6379
```

Optional (cache TTL in seconds; defaults in code if unset):
```
CACHE_TTL_SECONDS=60
CACHE_TTL_ONE_SECONDS=30
```

If `REDIS_URL` is missing or empty, the backend runs without Redis; all reads go to the database and no cache errors are thrown.
