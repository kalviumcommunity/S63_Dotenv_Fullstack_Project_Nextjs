# Backend API Server (Next.js) – CivicTrack

This is a Next.js API-only backend server running on port 5000 for **CivicTrack** (transparent urban grievance redressal).

## Setup

1. Install dependencies:
```bash
npm install
```

2. Generate Prisma client:
```bash
npx prisma generate
```

3. Run migrations (if needed):
```bash
npx prisma migrate deploy
```

4. Start development server:
```bash
npm run dev
```

The server will start on http://localhost:5000

## API Routes

- `GET /api/health` - Health check
- `GET /api/db/connection-test` - Secure DB connection test (returns `serverTime` only)
- `GET /api/test-db` - Test database connection
- `POST /api/auth/signup` - User signup
- `POST /api/auth/login` - User login
- `GET /api/issues` - List issues (query: category, status, limit, offset)
- `POST /api/issues` - Create issue (title, description, category, latitude, longitude, isAnonymous, reportedById)
- `GET /api/issues/:id` - Get issue by id or publicId (e.g. CT-00001)
- `PATCH /api/issues/:id` - Update issue (status, assignedToId, resolutionNotes, proofUrls, etc.)
- `DELETE /api/issues/:id` - Delete issue (admin only)
- `POST /api/storage/upload-url` - Get presigned upload URL (auth required)
- `POST /api/storage/download-url` - Get presigned download URL (auth required)
- `GET /api/secrets/test` - Verify secret retrieval (returns key names only, no values)
- `POST /api/secrets/refresh` - Clear secret cache for rotation (admin only)

## CivicTrack: Role enum

User `role` is one of: **citizen**, **officer**, **admin**. If you have an existing database with the old Role enum (`user`, `admin`), run a migration to add new values and map existing data (e.g. set `user` → `citizen`) before or after applying schema changes; see Prisma docs for enum migrations.

## Authentication vs Authorization

- **Authentication** answers: _"Who are you?"_
  - Implemented by `POST /api/auth/signup` and `POST /api/auth/login`.
  - On login, the backend verifies the email/password with Prisma and issues a **JWT** that includes the user id, email, and `role` (either `"user"` or `"admin"`).
  - The JWT is signed with `JWT_SECRET` loaded from environment variables; no secrets are hardcoded in the codebase.
- **Authorization** answers: _"What are you allowed to do?"_
  - Implemented by role-based checks (`role` field on the `User` model and `role` claim in the JWT).
  - Middleware and API routes use the `role` to decide if access should be granted or denied.

## Authorization Middleware (RBAC) Flow

> Note: The global authorization middleware is implemented in the frontend Next.js app and protects the `/api/users` and `/api/admin` routes. It uses the same `JWT_SECRET` so it can verify the JWTs generated by this backend.

- **1. Incoming request**
  - Client calls one of:
    - `GET /api/users`
    - `GET /api/admin`
  - Request must include `Authorization: Bearer <JWT>` header.
- **2. Middleware checks**
  - If the `Authorization` header is **missing**:
    - Returns a JSON error with **HTTP 401** (unauthorized).
  - If the token is **invalid or expired**:
    - Returns a JSON error with **HTTP 403** (forbidden).
  - If the path starts with `/api/admin` and the user `role` in the token is **not** `"admin"`:
    - Returns a JSON error with **HTTP 403** (forbidden).
  - On success:
    - Middleware attaches decoded user information to the request headers:
      - `x-user-email`
      - `x-user-role`
    - Request is forwarded to the target API route.
- **3. API route behavior**
  - `/api/users`:
    - Requires a **valid JWT** (any role: `"user"` or `"admin"`).
  - `/api/admin`:
    - Requires a **valid JWT** with `role === "admin"`.

All error responses are JSON only (no redirects), and use the shared `responseHandler.ts` and `errorCodes.ts` utilities for a consistent response shape.

## Role-Based Access Control (RBAC)

The application implements a comprehensive RBAC system with permission-based access control. See [RBAC.md](./RBAC.md) for complete documentation.

### Roles & Permissions

| Role | Permissions | Description |
|------|-------------|-------------|
| **citizen** | `create`, `read` | Can create issues (report) and read/view issues |
| **officer** | `read`, `update` | Can read issues and update progress/status |
| **admin** | `create`, `read`, `update`, `delete` | Full access to all operations |

### Enforcement

- **Backend**: All API routes enforce permissions via centralized middleware
- **Frontend**: UI elements conditionally render based on user permissions
- **Logging**: All permission checks are logged for auditing

### Allowed vs Denied Examples

- **Allowed**
  - `POST /api/issues` with a valid JWT for a `"citizen"` (has `create` permission): ✅ Allowed
  - `PATCH /api/issues/:id` with a valid JWT for an `"officer"` (has `update` permission): ✅ Allowed
  - `GET /api/users/officers` with a valid JWT for an `"admin"` (has `read` permission): ✅ Allowed
  - `DELETE /api/issues/:id` with a valid JWT for an `"admin"` (has `delete` permission): ✅ Allowed

- **Denied**
  - `PATCH /api/issues/:id` with a valid JWT for a `"citizen"` (no `update` permission): ❌ Forbidden (HTTP 403)
  - `DELETE /api/issues/:id` with a valid JWT for an `"officer"` (no `delete` permission): ❌ Forbidden (HTTP 403)
  - `GET /api/users/officers` with a valid JWT for a `"citizen"` (no `read` permission for this resource): ❌ Forbidden (HTTP 403)

For detailed RBAC documentation, see [RBAC.md](./RBAC.md).

### Enforcement Flow

1. **Incoming request** → API route receives request with `Authorization: Bearer <JWT>`
2. **Verify JWT** → Extract and verify token; reject with 401 if invalid/expired
3. **Extract role** → Role comes from verified JWT payload only; never from body or frontend
4. **Check permission** → Use centralized `ROLE_PERMISSIONS` mapping; deny by default
5. **If allowed** → Proceed; log `[RBAC] role=X action=Y resource=Z result=ALLOWED`
6. **If denied** → Return 403; log `[RBAC] role=X action=Y resource=Z result=DENIED`

### Example Log Output

```
[RBAC] role=admin action=delete resource=/api/issues/123 result=ALLOWED
[RBAC] role=officer action=delete resource=/api/issues/456 result=DENIED
```

### Scalability, Auditing & Future Extension

- **Scalability**: Single `ROLE_PERMISSIONS` config; add roles/permissions by extending the mapping
- **Auditing**: All checks logged in consistent format; easy to pipe to log aggregators
- **Extension**: Add new roles (e.g. `moderator`) or permissions (e.g. `approve`) by updating `backend/src/lib/rbac/permissions.ts`

## Security: XSS & SQL Injection Protection

The application implements OWASP-aligned input sanitization and output encoding to protect against XSS and SQL injection.

### XSS (Cross-Site Scripting) Risks

User-generated content (titles, descriptions, notes) could contain malicious HTML/JavaScript. Without sanitization, rendered in a browser it could execute scripts, steal sessions, or deface pages.

### SQL Injection Risks

Untrusted input concatenated into SQL queries can allow attackers to manipulate queries. The application uses **Prisma ORM** which parameterizes all queries—no raw string interpolation.

### Sanitization Utility

Centralized in `src/lib/security/sanitize.ts`:

- Uses **isomorphic-dompurify** to strip script tags, event handlers, malicious attributes
- Strips ALL HTML for plain-text storage (`ALLOWED_TAGS: []`)
- Rejects suspicious patterns (XSS, SQLi indicators) by default (fail-closed)
- Enforces input length limits per field
- Configurable for safe extensions

**Flow**: Validate (schema/required) → Sanitize → Store → Encode on render.

### Before/After Example

| Input | Result |
|-------|--------|
| `Hello World` | Passes unchanged |
| `<script>alert("XSS")</script>` | Rejected or stripped to empty |
| `' OR 1=1 --` | Rejected (SQLi pattern) |
| `<b>Bold</b> text` | Stripped to `Bold text` |

### OWASP Practices Followed

- **Validate then sanitize**: Never sanitize without validating; never trust sanitized input as fully safe
- **Backend enforcement**: All API inputs sanitized server-side; frontend validation is additive
- **Parameterized queries**: Prisma uses bound parameters; no concatenated SQL
- **Output encoding**: React escapes by default; no `dangerouslySetInnerHTML` with user content
- **Secure headers**: X-Content-Type-Options, X-Frame-Options, CSP, Referrer-Policy
- **Safe errors**: No stack traces or sensitive data in production responses

### Sanitization Demo

`POST /api/security/sanitize-demo` — controlled test (no DB storage):

```json
{"input": "<script>alert('XSS')</script>"}
→ {"sanitized": "", "wasModified": true, "rejected": true}
```

### Defense in Depth

1. **Input validation** (schema, format, length)
2. **Input sanitization** (strip/escape dangerous content)
3. **Parameterized DB queries** (Prisma)
4. **Output encoding** (React escaping, CSP)
5. **Secure headers** (CSP, X-Frame-Options, etc.)

### Future Improvements

- Rate limiting to reduce brute-force and DoS
- WAF (Web Application Firewall) for additional layer
- CSP nonces (Next.js) to remove `unsafe-inline` where possible
- Content-Security-Policy-Report-Only for monitoring

## HTTPS & Secure Headers

The backend enforces HTTPS and sets security headers for production deployments.

### 1. HTTPS Enforcement

- **Production only**: HTTP requests are redirected (308) to HTTPS.
- **Proxy-aware**: Uses `X-Forwarded-Proto` when behind load balancers (Vercel, nginx, Cloudflare).
- **Localhost exempt**: No redirect on `localhost` or `127.0.0.1`.
- Path and query parameters are preserved in the redirect.

### 2. HSTS (HTTP Strict Transport Security)

- **Header**: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
- **Production only**: Not set in development (avoids localhost issues).
- **1 year max-age**: Meets browser preload list requirements.
- **includeSubDomains**: Applies to all subdomains.
- **preload**: Eligible for browser preload lists.

### 3. Content Security Policy (CSP)

- `default-src 'self'`
- `script-src 'self' 'unsafe-inline'`
- `style-src 'self' 'unsafe-inline'`
- `img-src 'self' data: https:`
- `connect-src 'self' https:`
- `frame-ancestors 'none'` (clickjacking protection)
- `object-src 'none'`

### 4. CORS Configuration

- **Never `*` in production**: `CORS_ORIGIN` must be a specific trusted origin (e.g. `https://app.example.com`).
- **Multiple origins**: Use `CORS_ORIGINS` (comma-separated) for multiple frontends.
- **OPTIONS preflight**: Explicitly allowed methods and headers.
- **Credentials**: `Access-Control-Allow-Credentials: true` when using cookies/auth.

**Production `.env` example:**
```env
CORS_ORIGIN=https://app.example.com
CORS_ORIGINS=https://app.example.com,https://admin.example.com
```

### 5. Additional Security Headers

| Header | Value | Purpose |
|--------|-------|---------|
| X-Content-Type-Options | nosniff | Prevents MIME sniffing |
| X-Frame-Options | DENY | Prevents clickjacking |
| X-XSS-Protection | 1; mode=block | Legacy XSS filter (defense in depth) |
| Referrer-Policy | strict-origin-when-cross-origin | Limits referrer leakage |
| Permissions-Policy | camera=(), microphone=(), ... | Restricts browser features |

### Threats Mitigated

- **MITM**: HTTPS redirect + HSTS prevents downgrade attacks.
- **XSS**: CSP limits script sources; XSS-Protection adds defense in depth.
- **Clickjacking**: `frame-ancestors 'none'` and `X-Frame-Options: DENY`.
- **Data exfiltration**: CSP `connect-src` restricts outbound requests.
- **Cross-origin abuse**: CORS restricts API access to trusted origins.

### Testing

1. **HTTPS redirect**: `curl -I http://your-domain.com` → expect `308` to `https://`
2. **HSTS**: `curl -I https://your-domain.com` → expect `Strict-Transport-Security`
3. **CORS**: Inspect `Access-Control-Allow-Origin` in responses; must match your frontend origin.

## Least-Privilege Principle

This project follows the **least-privilege principle**:

- New users are created with the lowest privilege by default:
  - `role = "user"`.
- Admin-only routes (`/api/admin`) are strictly guarded:
  - Only tokens with `role === "admin"` are allowed through middleware.
- Shared middleware centralizes authorization logic:
  - Reduces duplication and the chance of accidentally exposing sensitive routes.
- The `role` is part of the JWT payload:
  - API routes can make additional fine-grained checks when necessary without performing extra database lookups.

By default, users can only access what they need (`/api/users` with valid JWT), while sensitive admin operations are limited to a small, trusted set of identities.

## Redis Caching (Optional)

A production-ready Redis caching layer is integrated to improve API performance for frequently read data. **Redis is completely optional** - the application works perfectly fine without it.

### Why Redis was added

- **Reduce database load**: List and single-issue GETs are read-heavy; caching avoids repeated Prisma/PostgreSQL round-trips.
- **Lower latency**: Cached responses are served from memory (Redis), so cold vs cached request latency is measurably lower.
- **Same API contract**: Response shapes and status codes are unchanged; caching is transparent to clients.

### Cache-aside strategy (lazy loading)

- **Flow**: On a GET request we first check Redis. On **cache hit** we return the stored JSON immediately. On **cache miss** we load from the database, store the serialized response in Redis with a TTL, then return it.
- **Single Redis instance**: The app uses one shared Redis client (see `src/lib/redis.ts`); connection is created from `REDIS_URL` and reused.
- **Error safety**: If Redis is unavailable or any cache operation fails, the API does not crash: we log a warning once and fall back to the database. Responses remain correct. The app runs normally without Redis.

### Running without Redis

To run the application without Redis, simply **remove or comment out** the `REDIS_URL` line in your `.env` file:

```env
# REDIS_URL=redis://localhost:6379  # Commented out - app runs without cache
```

The application will automatically detect that Redis is not configured and run without caching. All API endpoints will work normally, they'll just query the database directly instead of using cache.

### TTL policy and reasoning

- **List endpoint** (`GET /api/issues`): Default TTL **60 seconds** (`CACHE_TTL_SECONDS`). List data can tolerate short staleness; 60s keeps DB load down while keeping lists reasonably fresh.
- **Single-issue** (`GET /api/issues/:id`): Default TTL **30 seconds** (`CACHE_TTL_ONE_SECONDS`). Shorter so status/assignment updates appear sooner when an issue is updated.
- TTLs are configurable via environment variables so production can tune for traffic and freshness.

### Cache invalidation

- **On mutations we invalidate related cache** so stale data is not served:
  - **POST /api/issues** (create): Invalidates all issue list cache keys (`issues:list:*`).
  - **PATCH /api/issues/:id** (update): Invalidates the list cache and the single-issue cache for that id (both numeric and `publicId`).
  - **DELETE /api/issues/:id**: Invalidates list cache and single-issue cache.
- Invalidation is explicit and intentional: only these mutation paths clear cache; no background TTL-only reliance for consistency.

### Observability

- Console logs indicate **CACHE HIT**, **CACHE MISS**, and **CACHE INVALIDATE** (with key or pattern and count). Use these for performance analysis and debugging.
- Redis connection and command errors are logged internally; they do not surface as 5xx to the client.

### Performance impact

- **Cold request** (cache miss): Same as before—one DB query; response is then stored in Redis.
- **Cached request** (cache hit): No DB query; response is read from Redis and returned. Latency is typically much lower (e.g. single-digit ms vs tens of ms for DB).
- Throughput improves under repeated reads for the same query params or issue id.

### Stale data risks and mitigation

- **Risk**: A client might see list or single-issue data that is slightly out of date (up to one TTL window) if they do not trigger a mutation.
- **Mitigation**: (1) Mutations (POST, PATCH) invalidate the relevant keys so the next GET sees fresh data. (2) TTL limits how long any stale entry can live. (3) If Redis fails, every request falls back to the database, so correctness is preserved.

## Production Cloud PostgreSQL

The backend supports managed PostgreSQL hosted on **AWS RDS** or **Azure Database for PostgreSQL**, with SSL, connection pooling, and production security.

### Cloud Provider & Instance

| Provider | Example Instance | Region Example |
|----------|------------------|----------------|
| **AWS RDS** | db.t3.micro (free tier) or db.t3.small | us-east-1 |
| **Azure** | Basic B1ms or General Purpose D2s_v3 | East US |

Configure your instance per provider docs. The application is provider-agnostic—it connects via standard PostgreSQL protocol.

### Connection Setup

1. **Obtain connection details** from your cloud console (host, port 5432, database name, username, password).
2. **Set `DATABASE_URL`** in environment (never commit to git):

```env
# AWS RDS example (replace placeholders)
DATABASE_URL=postgresql://admin:YOUR_PASSWORD@my-db.abc123.us-east-1.rds.amazonaws.com:5432/mydb?sslmode=require

# Azure example (user format: username@servername)
DATABASE_URL=postgresql://admin@myserver:YOUR_PASSWORD@myserver.postgres.database.azure.com:5432/mydb?sslmode=require
```

3. **Run migrations**:

```bash
npx prisma migrate deploy
```

### Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `DATABASE_URL` | Yes | PostgreSQL connection string. Must be set or app throws at startup. |
| `DATABASE_CONNECTION_LIMIT` | No | Pool limit (default: 10). Use for serverless to prevent connection exhaustion. |

### SSL and Security

- **Production (`NODE_ENV=production`)**: SSL is **auto-appended** (`sslmode=require`) if not already in the URL.
- **Explicit SSL**: Include `?sslmode=require` (or `verify-full` for stricter cert validation) in your URL.
- **Credentials**: Never logged; never exposed in API responses or error messages.
- **Connection test**: `GET /api/db/connection-test` returns only `serverTime`; errors return a generic message in production.

### Network Configuration

- **IP allowlisting**: Add your application server's outbound IP(s) to the database firewall. For serverless (e.g. Vercel), you may need to allow a range or use a connector.
- **Private networking (recommended)**: Place the database in a private subnet (VPC/Private Link) and run the app in the same VPC. No public DB endpoint required.
- **Public access**: Simpler to set up but less secure. Use only with IP allowlisting and strong passwords.

### Backup Strategy

- **Cloud-level backups**: Enable automated daily backups in RDS or Azure. Retention: 7–35 days typical.
- **Point-in-time recovery (PITR)**: Both AWS and Azure support PITR for accidental deletion or corruption.
- **Application layer**: No backup logic in code; rely on provider-managed backups and replication.

### Public vs Private DB Access

| Approach | Pros | Cons |
|----------|------|------|
| **Private (VPC)** | Most secure, no public exposure | Requires app and DB in same network |
| **Public + IP allowlist** | Simpler, works with serverless | DB has a public endpoint; must maintain allowlist |

**Recommendation**: Use private networking when possible (e.g. app on EC2/ECS in same VPC as RDS).

### Future Scaling (Replicas, Failover)

- **Read replicas**: Architecture supports a separate read-only URL. Configure `directUrl` in Prisma for migrations and use a pooler URL for reads.
- **Failover**: Cloud providers handle automatic failover. Ensure `DATABASE_URL` points to the primary; update DNS/connection string if manual failover is needed.
- **Horizontal scaling**: Application layer is stateless; scale app instances independently. Connection pooling (`connection_limit`) prevents DB overload.

### Connection Test Evidence

After deployment, verify connectivity:

```bash
curl https://your-api.example.com/api/db/connection-test
```

**Success response (200):**

```json
{
  "ok": true,
  "serverTime": "2025-02-13T12:00:00.000Z"
}
```

**Failure response (503):**

```json
{
  "ok": false,
  "error": "Database connection failed"
}
```

In production, error messages are generic to avoid leaking hostnames or credentials.

---

## Supabase Storage (Private, Signed URLs)

The backend integrates **Supabase Storage** for secure file storage using signed URLs. The bucket is **private**; no public access. All uploads and downloads go through time-limited, signed URLs generated by the backend.

### Provider

- **Supabase Storage** via `@supabase/supabase-js`
- Uses **service role key** (server-side only) to generate signed URLs

### Bucket Configuration

1. Create a project at [supabase.com](https://supabase.com).
2. In **Storage**, create a new bucket (e.g. `uploads`).
3. Set the bucket to **Private** (no public read access).
4. Do **not** enable public access.
5. Optionally configure RLS policies; service role bypasses RLS for server-side operations.

### Required Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `SUPABASE_URL` | Yes* | Project URL (e.g. `https://xxx.supabase.co`) |
| `SUPABASE_SERVICE_ROLE_KEY` | Yes* | Service role key (from Project Settings → API) |
| `SUPABASE_BUCKET` | Yes* | Private bucket name |

*Required only when using storage features. If not set, storage endpoints return 503.

**Important**: Use the **service role** key, not the anon key. The service role key must never be exposed to the client.

Optional:

| Variable | Default | Description |
|----------|---------|-------------|
| `STORAGE_KEY_PREFIX` | `uploads` | Object key prefix |
| `STORAGE_MAX_FILE_SIZE_BYTES` | `2097152` (2MB) | Max file size |
| `STORAGE_ALLOWED_MIME_TYPES` | `image/png,image/jpeg,image/jpg,application/pdf` | Comma-separated MIME whitelist |

### Signed Upload Flow

1. **Client** authenticates (login) and receives JWT.
2. **Client** calls `POST /api/storage/upload-url` with:
   ```json
   { "fileName": "photo.png", "fileType": "image/png", "contentLength": 102400 }
   ```
3. **Backend** validates `fileName`, `fileType`, `contentLength` (MIME whitelist, size limit, path traversal prevention).
4. **Backend** generates signed upload URL via Supabase `createSignedUploadUrl`.
5. **Client** uploads file directly to Supabase Storage:
   - **Option A**: Use `fetch(uploadUrl, { method: 'POST', body: file, headers: { 'Content-Type': contentType } })`
   - **Option B**: Use Supabase client `storage.from(bucket).uploadToSignedUrl(path, token, file)`
6. **Client** stores the returned `key` (e.g. in issue `mediaUrls`) for later retrieval.

### Why Signed URLs Are Secure

- **No credentials on client**: The client never sees the service role key; the backend signs URLs.
- **Time-limited**: URLs expire shortly after generation.
- **Scoped**: Each URL grants access only to a single object (path).
- **Private bucket**: Bucket has no public access; only signed URLs work.

### File Validation Rules

- **MIME types**: Whitelist only (default: PNG, JPEG, PDF). Configure via `STORAGE_ALLOWED_MIME_TYPES`.
- **Max size**: Default 2MB; configurable via `STORAGE_MAX_FILE_SIZE_BYTES`. Cap: 50MB.
- **Path traversal**: Rejected (`..`, `/`, `\`, and unsafe chars).
- **fileName**: Sanitized (alphanumeric, dash, underscore, dot). Basename only (no path).

### Example Upload API Response

**Request:**
```
POST /api/storage/upload-url
Authorization: Bearer <JWT>
Content-Type: application/json
{"fileName": "evidence.png", "fileType": "image/png", "contentLength": 52428}
```

**Success (200):**
```json
{
  "success": true,
  "uploadUrl": "https://xxx.supabase.co/storage/v1/object/upload/sign/uploads/...?token=...",
  "key": "uploads/1234567890-evidence.png",
  "token": "...",
  "expiresInSeconds": 90,
  "contentType": "image/png",
  "contentLength": 52428
}
```

**Validation Error (400):**
```json
{
  "success": false,
  "error": { "code": "VALIDATION_ERROR", "message": "File type not allowed. Allowed: image/png, ..." },
  "message": "File type not allowed. Allowed: image/png, ..."
}
```

### Download URL Flow

- `POST /api/storage/download-url` with `{ "key": "uploads/1234567890-evidence.png" }`
- Requires `read` permission.
- Returns signed GET URL (60-second expiry).

### Lifecycle & Cost

- **Supabase free tier**: 1GB storage, 2GB bandwidth.
- **Auto-cleanup**: Configure bucket lifecycle in Supabase Dashboard (Storage → Bucket → Settings) to auto-delete objects older than N days if needed.
- **Cost optimization**: Keep bucket private; use signed URLs only. Monitor usage in Supabase dashboard.

### Security Best Practices

- Bucket is private (no public read).
- Service role key only in server environment variables; never in client or logs.
- No wildcard storage policies.
- File validation enforced before URL generation.

---

## Environment Variables

Create a `.env` file with:
```
DATABASE_URL=postgresql://postgres:password@localhost:5432/mydb
PORT=5000
JWT_SECRET=your-secret-key
REDIS_URL=redis://localhost:6379
```

Optional (cache TTL in seconds; defaults in code if unset):
```
CACHE_TTL_SECONDS=60
CACHE_TTL_ONE_SECONDS=30
```

Optional (connection pool limit for serverless; default 10):
```
DATABASE_CONNECTION_LIMIT=10
```

**Supabase Storage** (optional; if missing, storage endpoints return 503):
```
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
SUPABASE_BUCKET=uploads
STORAGE_MAX_FILE_SIZE_BYTES=2097152
STORAGE_ALLOWED_MIME_TYPES=image/png,image/jpeg,image/jpg,application/pdf
```

**Supabase Vault** (optional; for production secret management):
```
SECRET_PROVIDER=supabase
SUPABASE_DATABASE_URL=postgresql://postgres.[ref]:[password]@...[pooler]:6543/postgres
SECRET_CACHE_TTL_SECONDS=300
```

If `REDIS_URL` is missing or empty, the backend runs without Redis; all reads go to the database and no cache errors are thrown.

---

## Cloud Secret Management (Supabase Vault)

For production, **do not store plaintext secrets in `.env` or in the repository**. Use **Supabase Vault** for runtime injection—encrypted secrets stored in your Supabase Postgres.

### Why `.env` is Unsafe for Production

- **Version control**: `.env` can be committed by mistake; secrets persist in git history.
- **Deployment artifacts**: Build logs, container images, or CI/CD caches may contain env values.
- **Shared access**: Developers with repo access see all secrets; no granular revocation.
- **No audit trail**: No record of who accessed which secret when.
- **Rotation friction**: Changing a secret requires redeploying; no zero-downtime rotation.

### Provider: Supabase Vault

- **Detection**: `SECRET_PROVIDER=supabase`
- **Storage**: Supabase Vault (Postgres extension, encrypted at rest)
- **Access**: Direct Postgres connection to query `vault.decrypted_secrets`

When `SECRET_PROVIDER` is not set, the app uses `process.env` (local `.env`) as before.

### Secret Storage Structure

1. Go to **Supabase Dashboard** → **Project Settings** → **Vault** (or Database → Vault).
2. Create secrets with **names** that match your env keys: `DATABASE_URL`, `JWT_SECRET`, `JWT_REFRESH_SECRET`, etc.
3. The app queries `vault.decrypted_secrets` and maps `name` → `decrypted_secret`.

**Example (SQL):**
```sql
SELECT vault.create_secret('postgresql://...', 'DATABASE_URL', 'Database connection string');
SELECT vault.create_secret('your-jwt-secret', 'JWT_SECRET', 'JWT signing key');
```

### Required Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `SECRET_PROVIDER` | Yes | `supabase` |
| `SUPABASE_DATABASE_URL` | Yes | Postgres connection string (from Settings → Database → Connection string, URI, Transaction mode) |

Optional:
| Variable | Default | Description |
|----------|---------|-------------|
| `SUPABASE_VAULT_KEYS` | All | Comma-separated keys to load. If omitted, loads all vault secrets with a name. |
| `SECRET_CACHE_TTL_SECONDS` | 300 | Cache TTL |

**Getting `SUPABASE_DATABASE_URL`**: Supabase Dashboard → **Settings** → **Database** → **Connection string** → **URI** (Transaction pooler, port 6543).

### Least Privilege

- The database user in `SUPABASE_DATABASE_URL` needs only **SELECT** on `vault.decrypted_secrets`.
- Do not grant INSERT/UPDATE/DELETE on vault tables to the app role.
- Use a dedicated DB role for secret retrieval with minimal privileges.

### Runtime Injection

1. **Instrumentation**: On server startup (`instrumentation.ts`), if `SECRET_PROVIDER=supabase`, the app fetches secrets from Supabase Vault and populates `process.env` for keys not already set.
2. **Existing code unchanged**: Database config, auth, and other modules continue to read from `process.env`.
3. **Server-side only**: Secrets are never bundled into client code or sent to the browser.
4. **No window / global exposure**: No secrets on `window` or in error messages.

### Secret Caching

- **In-memory cache**: Fetched secrets are cached for `SECRET_CACHE_TTL_SECONDS` (default 5 minutes).
- **Fewer DB calls**: High traffic does not cause repeated vault queries.
- **Race handling**: Concurrent first requests share one fetch; no duplicate calls.
- **Manual refresh**: `POST /api/secrets/refresh` (admin) clears cache; next access refetches.

### Rotation Strategy

1. **Update in Vault**: Use Supabase Dashboard or `vault.update_secret()` to rotate secrets.
2. **App refresh**: Call `POST /api/secrets/refresh` or wait for cache TTL.
3. **No restart**: Secrets are refetched on next access; no app restart needed.

### Trust Boundaries

- **Trusted**: Server (API routes, server components) – can call `getSecret()`.
- **Untrusted**: Browser, client components – must never receive secrets.
- **Semi-trusted**: CI/CD – has deployment secrets; never commit them.

### Proof of Successful Retrieval

Call `GET /api/secrets/test`:

**Success (Supabase Vault configured):**
```json
{
  "ok": true,
  "provider": "supabase",
  "keysRetrieved": ["DATABASE_URL", "JWT_SECRET", "JWT_REFRESH_SECRET"],
  "keyCount": 3,
  "message": "Secrets retrieved successfully (values not exposed)"
}
```

**Success (no cloud):**
```json
{
  "ok": true,
  "provider": "none",
  "message": "Cloud secrets not configured (using .env)",
  "keysRetrieved": []
}
```

Never log or return secret values. Only key names (metadata) are exposed.

### CI/CD Integration (Future)

- Store `SECRET_PROVIDER` and `SUPABASE_DATABASE_URL` in CI secrets.
- Do not store `DATABASE_URL`, `JWT_SECRET`, etc. in CI if using Supabase Vault.
